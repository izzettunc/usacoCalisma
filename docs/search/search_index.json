{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to stibnite \u00b6 stibnite \u00b6 Automated python documentation generator \u00b6 Disclaimer \u00b6 As the developers of this project we take it as one\u2019s duty to thank AlexandreKempf and other contributers in the automacdoc project as they are the visionary fathers/mothers of stibnite.","title":"Home"},{"location":"#welcome-to-stibnite","text":"","title":"Welcome to stibnite"},{"location":"#stibnite","text":"","title":"stibnite"},{"location":"#automated-python-documentation-generator","text":"","title":"Automated python documentation generator"},{"location":"#disclaimer","text":"As the developers of this project we take it as one\u2019s duty to thank AlexandreKempf and other contributers in the automacdoc project as they are the visionary fathers/mothers of stibnite.","title":"Disclaimer"},{"location":"stibnite/stibnite/core_types/","text":"ClassType class \u00b6 This is a class with a sole purpose of storing information about the classes in a python file Parameters obj: object \u2013 A python live object of a class that is going to be documented class functions & static methods: __init__ __init__ ( self , obj ) \u00b6 Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def __init__ ( self , obj ): import inspect self . name = obj . __name__ self . obj = obj self . module = obj . __module__ self . path = inspect . getmodule ( obj ) . __file__ self . doc = obj . __doc__ or \"\" try : self . source = inspect . getsource ( obj ) if obj . __doc__ is None \\ else inspect . getsource ( obj ) . replace ( obj . __doc__ , '' ) . replace ( '\"\"\"' , '' ) except : self . source = \"\" try : self . args = str ( inspect . signature ( obj )) except : self . args = \"\" self . functions = [ FunctionType ( obj ) for name , obj in inspect . getmembers ( obj , inspect . isfunction )] self . methods = [ FunctionType ( obj ) for name , obj in inspect . getmembers ( obj , inspect . ismethod )] FunctionType class \u00b6 This is a class with a sole purpose of storing information about the functions or methods in a python file or in a python class Parameters obj: object \u2013 A python live object of a function or a method that is going to be documented class functions & static methods: __init__ __init__ ( self , obj ) \u00b6 Source Code 1 2 3 4 5 6 7 8 9 10 11 def __init__ ( self , obj ): import inspect self . name = obj . __name__ self . name_in_list = obj . __name__ self . obj = obj self . module = obj . __module__ self . path = inspect . getmodule ( obj ) . __file__ self . doc = obj . __doc__ or \"\" self . source = inspect . getsource ( obj ) if obj . __doc__ is None \\ else inspect . getsource ( obj ) . replace ( obj . __doc__ , '' ) . replace ( '\"\"\"' , '' ) self . args = str ( inspect . signature ( obj ))","title":"Core types"},{"location":"stibnite/stibnite/core_types/#ClassType","text":"This is a class with a sole purpose of storing information about the classes in a python file Parameters obj: object \u2013 A python live object of a class that is going to be documented class functions & static methods: __init__","title":"ClassType"},{"location":"stibnite/stibnite/core_types/#--init--","text":"Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def __init__ ( self , obj ): import inspect self . name = obj . __name__ self . obj = obj self . module = obj . __module__ self . path = inspect . getmodule ( obj ) . __file__ self . doc = obj . __doc__ or \"\" try : self . source = inspect . getsource ( obj ) if obj . __doc__ is None \\ else inspect . getsource ( obj ) . replace ( obj . __doc__ , '' ) . replace ( '\"\"\"' , '' ) except : self . source = \"\" try : self . args = str ( inspect . signature ( obj )) except : self . args = \"\" self . functions = [ FunctionType ( obj ) for name , obj in inspect . getmembers ( obj , inspect . isfunction )] self . methods = [ FunctionType ( obj ) for name , obj in inspect . getmembers ( obj , inspect . ismethod )]","title":"__init__"},{"location":"stibnite/stibnite/core_types/#FunctionType","text":"This is a class with a sole purpose of storing information about the functions or methods in a python file or in a python class Parameters obj: object \u2013 A python live object of a function or a method that is going to be documented class functions & static methods: __init__","title":"FunctionType"},{"location":"stibnite/stibnite/core_types/#--init--","text":"Source Code 1 2 3 4 5 6 7 8 9 10 11 def __init__ ( self , obj ): import inspect self . name = obj . __name__ self . name_in_list = obj . __name__ self . obj = obj self . module = obj . __module__ self . path = inspect . getmodule ( obj ) . __file__ self . doc = obj . __doc__ or \"\" self . source = inspect . getsource ( obj ) if obj . __doc__ is None \\ else inspect . getsource ( obj ) . replace ( obj . __doc__ , '' ) . replace ( '\"\"\"' , '' ) self . args = str ( inspect . signature ( obj ))","title":"__init__"},{"location":"stibnite/stibnite/docstring_styler/","text":"DocstringParser class \u00b6 This class is the main class to be used for parsing supported docstrings. Parameters style: string \u2013 The style that documentation written in class functions & static methods: __init__ _parse_rest parse_docstring __init__ ( self , style ) \u00b6 Source Code 1 2 def __init__ ( self , style ): self . style = style _parse_rest ( docstring ) \u00b6 Parses docstrings that are written in reStructered text. Parameters docstring: string \u2013 Docstring that is going to be parsed Returns A tuple that contains two value which are a string and a dictionary \u2013 A tuple which contains an explanation and information about parameters Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @staticmethod def _parse_rest ( docstring ): parts = docstring . split ( \":rtype:\" ) return_type = parts [ - 1 ] if len ( parts ) > 1 else None parts = parts [ 0 ] . split ( \":return:\" ) return_exp = parts [ - 1 ] if len ( parts ) > 1 else None parts = parts [ 0 ] . split ( \":param \" ) explanation = parts [ 0 ] params_info = [{ constants . NAME : constants . RETURN , constants . EXPLANATION : return_exp , constants . TYPE : return_type }] for i in range ( 1 , len ( parts )): param_info = {} param = parts [ i ] param_parts = param . split ( \":type \" ) param_exp = param_parts [ 0 ] param_type = param_parts [ 1 ] if len ( param_parts ) > 1 else None param_info [ constants . NAME ] = param_exp . split ( \":\" )[ 0 ] param_info [ constants . EXPLANATION ] = \":\" . join ( param_exp . split ( \":\" )[ 1 :]) param_info [ constants . TYPE ] = \":\" . join ( param_type . split ( \":\" )[ 1 :]) if param_type is not None else None params_info . append ( param_info ) return explanation , params_info parse_docstring ( self , docstring ) \u00b6 Parses given string and returns two ouput (for now) that contains all the information about the docstring. Parameters docstring: string \u2013 Docstring that is going to be parsed Returns A tuple that contains two value which are a string and a dictionary \u2013 A tuple which contains an explanation and information about parameters Source Code 1 2 3 def parse_docstring ( self , docstring ): return eval ( f \"DocstringParser._parse_ { self . style } (docstring)\" ) DocstringStyler class \u00b6 This class is the main class that stylize the information that is collected from python files into documentation with given style. Parameters input_style: string \u2013 The style that the documentation written in output_style: string \u2013 The style that the documentation will be written in class functions & static methods: __init__ _style_class_md _style_class_name_md _style_docstring_md _style_file_md _style_func_md _style_function_name_in_list_md _style_function_name_md _style_method_name_md _style_source_code_md <lambda> get_styled_structure __init__ ( self , output_style , input_style ) \u00b6 Source Code 1 2 3 def __init__ ( self , output_style , input_style ): self . output_style = output_style self . input_style = input_style _style_class_md ( clas , input_style ) \u00b6 Stylizes the given class in markdown style Parameters clas: stibnite.core_types.ClassType \u2013 The class that is going to be stylized input_style: string \u2013 Style of the inputted docstring Returns stibnite.core_types.ClassType \u2013 The same class but name, doc, methods and functions fields are changed with stylized version of them Source Code 1 2 3 4 5 6 7 8 9 10 11 @staticmethod def _style_class_md ( clas , input_style ): clas . name = DocstringStyler . _style_class_name_md ( clas . name ) clas . doc = DocstringStyler . _style_docstring_md ( clas . doc , input_style ) for i in range ( len ( clas . methods )): clas . methods [ i ] = DocstringStyler . _style_func_md ( clas . methods [ i ], input_style , True ) for i in range ( len ( clas . functions )): clas . functions [ i ] = DocstringStyler . _style_func_md ( clas . functions [ i ], input_style ) return clas _style_class_name_md ( class_name ) \u00b6 Stylizes the given class name in markdown style Parameters class_name: string \u2013 Name of the class Returns string \u2013 Class name stylized in markdown style Source Code 1 2 3 4 5 @staticmethod def _style_class_name_md ( class_name ): class_name = DocstringStyler . escape ( class_name ) return f \"## ** { class_name } **`#!py3 class` {{ # { class_name } data-toc-label= { class_name } }}\\n\\n \" _style_docstring_md ( docstring , input_style ) \u00b6 Stylizes the docstring in markdown style Parameters docstring: string \u2013 The docstring that is going to be stylized input_style: string \u2013 Style of the inputted docstring Returns string \u2013 The docstring stylized in markdown style Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @staticmethod def _style_docstring_md ( docstring , input_style ): if input_style == constants . MARKDOWN : rows = docstring . split ( \" \\n \" ) first_string = None for row in rows : if not row . isspace () and row != '' : first_string = row break if first_string is None : return docstring nb_indent = len ( first_string ) - len ( first_string . lstrip ()) for i in range ( len ( rows )): if len ( rows [ i ]) > nb_indent : rows [ i ] = rows [ i ][ nb_indent :] doc = ' \\n ' . join ( rows ) doc = f \" { doc } \\n\\n \" else : explanation , params = DocstringParser ( input_style ) . parse_docstring ( docstring ) doc = \"\" rows = explanation . split ( \" \\n \" ) rows = [ row for row in rows if row != \"\" and not row . isspace ()] for i in range ( len ( rows )): rows [ i ] = rows [ i ] . lstrip () . rstrip () explanation = \" \" . join ( rows ) doc += f \" { explanation } \\n\\n \" if not explanation . isspace () and explanation != \"\" else \"\" if len ( params ) > 1 : doc += f \"**Parameters** \\n\\n \" for i in range ( 1 , len ( params )): if params [ i ][ constants . TYPE ] is not None : doc += f \"> ** { params [ i ][ constants . NAME ] . lstrip () . rstrip () } :** ` { params [ i ][ constants . TYPE ] . lstrip () . rstrip () } ` -- { params [ i ][ constants . EXPLANATION ] . lstrip () . rstrip () } \\n\\n \" else : doc += f \"> ** { params [ i ][ constants . NAME ] . lstrip () . rstrip () } :** `n/a` -- { params [ i ][ constants . EXPLANATION ] . lstrip () . rstrip () } \\n\\n \" if params [ 0 ][ constants . TYPE ] is not None or params [ 0 ][ constants . EXPLANATION ] is not None : doc += f \"**Returns** \\n\\n > ` { params [ 0 ][ constants . TYPE ] . lstrip () . rstrip () if params [ 0 ][ constants . TYPE ] is not None else 'n/a' } `\" desc = ' -- ' + params [ 0 ][ constants . EXPLANATION ] . lstrip () . rstrip () if params [ 0 ][ constants . EXPLANATION ] is not None else '' doc += f \" { desc } \\n\\n \" return doc _style_file_md ( file , input_style ) \u00b6 Stylizes the given file structure in markdown style Parameters file: stibnite.file_operations.FileType \u2013 The file that is going to be stylized Returns stibnite.file_operations.FileType \u2013 The same file but documentation field is filled with stylized documentation text Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @staticmethod def _style_file_md ( file , input_style ): documentation = \"\" for i in range ( len ( file . classes )): styled_class = DocstringStyler . _style_class_md ( copy . deepcopy ( file . classes [ i ]), input_style ) documentation += styled_class . name documentation += styled_class . doc if not styled_class . doc . isspace () else \"\" if len ( styled_class . methods ) > 0 : documentation += f \"**class methods:** \\n\\n \" for method in styled_class . methods : documentation += method . name_in_list if len ( styled_class . functions ) > 0 : documentation += f \"**class functions & static methods:** \\n\\n \" for function in styled_class . functions : documentation += function . name_in_list for method in styled_class . methods : documentation += method . name documentation += method . doc if not method . doc . isspace () else \"\" documentation += method . source for function in styled_class . functions : documentation += function . name documentation += function . doc if not function . doc . isspace () else \"\" documentation += function . source documentation += \"______ \\n\\n \" for i in range ( len ( file . functions )): styled_function = DocstringStyler . _style_func_md ( file . functions [ i ], input_style ) documentation += styled_function . name documentation += styled_function . doc documentation += styled_function . source documentation += \"______ \\n\\n \" file . documentation = { constants . FORMAT : constants . MARKDOWN , constants . CONTENT : documentation } return file _style_func_md ( func , input_style , ismethod = False ) \u00b6 Stylizes the given function or method in markdown style Parameters func: stibnite.core_types.FunctionType \u2013 The function that is going to be stylized input_style: string \u2013 Style of the inputted docstring ismethod: bool, optional \u2013 Flag that changes styling from function styling to method styling, defaults to False Returns stibnite.core_types.FunctionType \u2013 The same function or method but name, name_in_list, doc and source fields are changed with stylized version of them Source Code 1 2 3 4 5 6 7 8 9 10 11 12 @staticmethod def _style_func_md ( func , input_style , ismethod = False ): if ismethod : func . name = DocstringStyler . _style_method_name_md ( func . obj . __self__ . __class__ . __name__ , func . name , func . args ) else : func . name = DocstringStyler . _style_function_name_md ( func . name , func . args ) func . name_in_list = DocstringStyler . _style_function_name_in_list_md ( func . name_in_list ) func . doc = DocstringStyler . _style_docstring_md ( func . doc , input_style ) func . source = DocstringStyler . _style_source_code_md ( func . source ) return func _style_function_name_in_list_md ( name_in_list ) \u00b6 Stylizes the given function name to list functions of classes in markdown style Parameters name_in_list: string \u2013 Name of the function Returns string \u2013 Function name stylized in markdown style Source Code 1 2 3 4 @staticmethod def _style_function_name_in_list_md ( name_in_list ): return f \" - [` { name_in_list } `](# { name_in_list } ) \\n\\n \" _style_function_name_md ( function_name , args ) \u00b6 Stylizes the given function name in markdown style Parameters function_name: string \u2013 Name of the function args: string \u2013 Arguments seperated with \u2018,\u2019 Returns string \u2013 Function name stylized in markdown style Source Code 1 2 3 4 5 @staticmethod def _style_function_name_md ( function_name , args ): function_name = DocstringStyler . escape ( function_name ) return f \"## ** { function_name } **`#!py3 { args } ` {{ # { function_name } data-toc-label= { function_name } }}\\n\\n \" _style_method_name_md ( class_name , method_name , args ) \u00b6 Stylizes the given method name in markdown style Parameters class_name: string \u2013 Name of the method\u2019s parent class method_name: string \u2013 Name of the method args: string \u2013 Arguments seperated with \u2018,\u2019 Returns string \u2013 Method name stylized in markdown style Source Code 1 2 3 4 5 6 @staticmethod def _style_method_name_md ( class_name , method_name , args ): class_name = DocstringStyler . escape ( class_name ) method_name = DocstringStyler . escape ( method_name ) return f \"### * { class_name } *.** { method_name } **`#!py3 { args } ` {{ # { method_name } data-toc-label= { method_name } }}\\n\\n \" _style_source_code_md ( source_code ) \u00b6 Stylizes the source code in markdown style Parameters source_code: string \u2013 The source code that is going to be stylized Returns string \u2013 The source code stylized in markdown style Source Code 1 2 3 4 5 6 7 8 9 10 @staticmethod def _style_source_code_md ( source_code ): # Fixes indentations source = source_code . split ( \" \\n \" ) nb_indent = len ( source [ 0 ]) - len ( source [ 0 ] . lstrip ()) source_code = \"\" for i in range ( len ( source )): source_code += f \" \\t { source [ i ][ nb_indent :] } \\n \" return f '??? info \"Source Code\" \\n\\t ```py3 linenums=\"1 1 2\" \\n\\n { source_code } \\n\\t ``` \\n\\n ' ( text ) \u00b6 Source Code 1 escape = lambda text : text . replace ( '_' , ' \\\\ _' ) get_styled_structure ( self , file_structure ) \u00b6 Stylizes the given file structure Parameters file_structure: stibnite.file_operations.FolderType \u2013 The root of the file structure that is going to be traversed to stylize Returns stibnite.file_operations.FolderType \u2013 The same root but each documentation field in stibnite.file_operations.FileType under the file structure of the root is filled with stylized documentation text Source Code 1 2 3 def get_styled_structure ( self , file_structure ): return eval ( f \"utils.traverse_file_structure(file_structure, DocstringStyler._style_file_ { self . output_style } , input_style=self.input_style)\" )","title":"Docstring styler"},{"location":"stibnite/stibnite/docstring_styler/#DocstringParser","text":"This class is the main class to be used for parsing supported docstrings. Parameters style: string \u2013 The style that documentation written in class functions & static methods: __init__ _parse_rest parse_docstring","title":"DocstringParser"},{"location":"stibnite/stibnite/docstring_styler/#--init--","text":"Source Code 1 2 def __init__ ( self , style ): self . style = style","title":"__init__"},{"location":"stibnite/stibnite/docstring_styler/#-parse-rest","text":"Parses docstrings that are written in reStructered text. Parameters docstring: string \u2013 Docstring that is going to be parsed Returns A tuple that contains two value which are a string and a dictionary \u2013 A tuple which contains an explanation and information about parameters Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @staticmethod def _parse_rest ( docstring ): parts = docstring . split ( \":rtype:\" ) return_type = parts [ - 1 ] if len ( parts ) > 1 else None parts = parts [ 0 ] . split ( \":return:\" ) return_exp = parts [ - 1 ] if len ( parts ) > 1 else None parts = parts [ 0 ] . split ( \":param \" ) explanation = parts [ 0 ] params_info = [{ constants . NAME : constants . RETURN , constants . EXPLANATION : return_exp , constants . TYPE : return_type }] for i in range ( 1 , len ( parts )): param_info = {} param = parts [ i ] param_parts = param . split ( \":type \" ) param_exp = param_parts [ 0 ] param_type = param_parts [ 1 ] if len ( param_parts ) > 1 else None param_info [ constants . NAME ] = param_exp . split ( \":\" )[ 0 ] param_info [ constants . EXPLANATION ] = \":\" . join ( param_exp . split ( \":\" )[ 1 :]) param_info [ constants . TYPE ] = \":\" . join ( param_type . split ( \":\" )[ 1 :]) if param_type is not None else None params_info . append ( param_info ) return explanation , params_info","title":"_parse_rest"},{"location":"stibnite/stibnite/docstring_styler/#parse-docstring","text":"Parses given string and returns two ouput (for now) that contains all the information about the docstring. Parameters docstring: string \u2013 Docstring that is going to be parsed Returns A tuple that contains two value which are a string and a dictionary \u2013 A tuple which contains an explanation and information about parameters Source Code 1 2 3 def parse_docstring ( self , docstring ): return eval ( f \"DocstringParser._parse_ { self . style } (docstring)\" )","title":"parse_docstring"},{"location":"stibnite/stibnite/docstring_styler/#DocstringStyler","text":"This class is the main class that stylize the information that is collected from python files into documentation with given style. Parameters input_style: string \u2013 The style that the documentation written in output_style: string \u2013 The style that the documentation will be written in class functions & static methods: __init__ _style_class_md _style_class_name_md _style_docstring_md _style_file_md _style_func_md _style_function_name_in_list_md _style_function_name_md _style_method_name_md _style_source_code_md <lambda> get_styled_structure","title":"DocstringStyler"},{"location":"stibnite/stibnite/docstring_styler/#--init--","text":"Source Code 1 2 3 def __init__ ( self , output_style , input_style ): self . output_style = output_style self . input_style = input_style","title":"__init__"},{"location":"stibnite/stibnite/docstring_styler/#-style-class-md","text":"Stylizes the given class in markdown style Parameters clas: stibnite.core_types.ClassType \u2013 The class that is going to be stylized input_style: string \u2013 Style of the inputted docstring Returns stibnite.core_types.ClassType \u2013 The same class but name, doc, methods and functions fields are changed with stylized version of them Source Code 1 2 3 4 5 6 7 8 9 10 11 @staticmethod def _style_class_md ( clas , input_style ): clas . name = DocstringStyler . _style_class_name_md ( clas . name ) clas . doc = DocstringStyler . _style_docstring_md ( clas . doc , input_style ) for i in range ( len ( clas . methods )): clas . methods [ i ] = DocstringStyler . _style_func_md ( clas . methods [ i ], input_style , True ) for i in range ( len ( clas . functions )): clas . functions [ i ] = DocstringStyler . _style_func_md ( clas . functions [ i ], input_style ) return clas","title":"_style_class_md"},{"location":"stibnite/stibnite/docstring_styler/#-style-class-name-md","text":"Stylizes the given class name in markdown style Parameters class_name: string \u2013 Name of the class Returns string \u2013 Class name stylized in markdown style Source Code 1 2 3 4 5 @staticmethod def _style_class_name_md ( class_name ): class_name = DocstringStyler . escape ( class_name ) return f \"## ** { class_name } **`#!py3 class` {{ # { class_name } data-toc-label= { class_name } }}\\n\\n \"","title":"_style_class_name_md"},{"location":"stibnite/stibnite/docstring_styler/#-style-docstring-md","text":"Stylizes the docstring in markdown style Parameters docstring: string \u2013 The docstring that is going to be stylized input_style: string \u2013 Style of the inputted docstring Returns string \u2013 The docstring stylized in markdown style Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @staticmethod def _style_docstring_md ( docstring , input_style ): if input_style == constants . MARKDOWN : rows = docstring . split ( \" \\n \" ) first_string = None for row in rows : if not row . isspace () and row != '' : first_string = row break if first_string is None : return docstring nb_indent = len ( first_string ) - len ( first_string . lstrip ()) for i in range ( len ( rows )): if len ( rows [ i ]) > nb_indent : rows [ i ] = rows [ i ][ nb_indent :] doc = ' \\n ' . join ( rows ) doc = f \" { doc } \\n\\n \" else : explanation , params = DocstringParser ( input_style ) . parse_docstring ( docstring ) doc = \"\" rows = explanation . split ( \" \\n \" ) rows = [ row for row in rows if row != \"\" and not row . isspace ()] for i in range ( len ( rows )): rows [ i ] = rows [ i ] . lstrip () . rstrip () explanation = \" \" . join ( rows ) doc += f \" { explanation } \\n\\n \" if not explanation . isspace () and explanation != \"\" else \"\" if len ( params ) > 1 : doc += f \"**Parameters** \\n\\n \" for i in range ( 1 , len ( params )): if params [ i ][ constants . TYPE ] is not None : doc += f \"> ** { params [ i ][ constants . NAME ] . lstrip () . rstrip () } :** ` { params [ i ][ constants . TYPE ] . lstrip () . rstrip () } ` -- { params [ i ][ constants . EXPLANATION ] . lstrip () . rstrip () } \\n\\n \" else : doc += f \"> ** { params [ i ][ constants . NAME ] . lstrip () . rstrip () } :** `n/a` -- { params [ i ][ constants . EXPLANATION ] . lstrip () . rstrip () } \\n\\n \" if params [ 0 ][ constants . TYPE ] is not None or params [ 0 ][ constants . EXPLANATION ] is not None : doc += f \"**Returns** \\n\\n > ` { params [ 0 ][ constants . TYPE ] . lstrip () . rstrip () if params [ 0 ][ constants . TYPE ] is not None else 'n/a' } `\" desc = ' -- ' + params [ 0 ][ constants . EXPLANATION ] . lstrip () . rstrip () if params [ 0 ][ constants . EXPLANATION ] is not None else '' doc += f \" { desc } \\n\\n \" return doc","title":"_style_docstring_md"},{"location":"stibnite/stibnite/docstring_styler/#-style-file-md","text":"Stylizes the given file structure in markdown style Parameters file: stibnite.file_operations.FileType \u2013 The file that is going to be stylized Returns stibnite.file_operations.FileType \u2013 The same file but documentation field is filled with stylized documentation text Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @staticmethod def _style_file_md ( file , input_style ): documentation = \"\" for i in range ( len ( file . classes )): styled_class = DocstringStyler . _style_class_md ( copy . deepcopy ( file . classes [ i ]), input_style ) documentation += styled_class . name documentation += styled_class . doc if not styled_class . doc . isspace () else \"\" if len ( styled_class . methods ) > 0 : documentation += f \"**class methods:** \\n\\n \" for method in styled_class . methods : documentation += method . name_in_list if len ( styled_class . functions ) > 0 : documentation += f \"**class functions & static methods:** \\n\\n \" for function in styled_class . functions : documentation += function . name_in_list for method in styled_class . methods : documentation += method . name documentation += method . doc if not method . doc . isspace () else \"\" documentation += method . source for function in styled_class . functions : documentation += function . name documentation += function . doc if not function . doc . isspace () else \"\" documentation += function . source documentation += \"______ \\n\\n \" for i in range ( len ( file . functions )): styled_function = DocstringStyler . _style_func_md ( file . functions [ i ], input_style ) documentation += styled_function . name documentation += styled_function . doc documentation += styled_function . source documentation += \"______ \\n\\n \" file . documentation = { constants . FORMAT : constants . MARKDOWN , constants . CONTENT : documentation } return file","title":"_style_file_md"},{"location":"stibnite/stibnite/docstring_styler/#-style-func-md","text":"Stylizes the given function or method in markdown style Parameters func: stibnite.core_types.FunctionType \u2013 The function that is going to be stylized input_style: string \u2013 Style of the inputted docstring ismethod: bool, optional \u2013 Flag that changes styling from function styling to method styling, defaults to False Returns stibnite.core_types.FunctionType \u2013 The same function or method but name, name_in_list, doc and source fields are changed with stylized version of them Source Code 1 2 3 4 5 6 7 8 9 10 11 12 @staticmethod def _style_func_md ( func , input_style , ismethod = False ): if ismethod : func . name = DocstringStyler . _style_method_name_md ( func . obj . __self__ . __class__ . __name__ , func . name , func . args ) else : func . name = DocstringStyler . _style_function_name_md ( func . name , func . args ) func . name_in_list = DocstringStyler . _style_function_name_in_list_md ( func . name_in_list ) func . doc = DocstringStyler . _style_docstring_md ( func . doc , input_style ) func . source = DocstringStyler . _style_source_code_md ( func . source ) return func","title":"_style_func_md"},{"location":"stibnite/stibnite/docstring_styler/#-style-function-name-in-list-md","text":"Stylizes the given function name to list functions of classes in markdown style Parameters name_in_list: string \u2013 Name of the function Returns string \u2013 Function name stylized in markdown style Source Code 1 2 3 4 @staticmethod def _style_function_name_in_list_md ( name_in_list ): return f \" - [` { name_in_list } `](# { name_in_list } ) \\n\\n \"","title":"_style_function_name_in_list_md"},{"location":"stibnite/stibnite/docstring_styler/#-style-function-name-md","text":"Stylizes the given function name in markdown style Parameters function_name: string \u2013 Name of the function args: string \u2013 Arguments seperated with \u2018,\u2019 Returns string \u2013 Function name stylized in markdown style Source Code 1 2 3 4 5 @staticmethod def _style_function_name_md ( function_name , args ): function_name = DocstringStyler . escape ( function_name ) return f \"## ** { function_name } **`#!py3 { args } ` {{ # { function_name } data-toc-label= { function_name } }}\\n\\n \"","title":"_style_function_name_md"},{"location":"stibnite/stibnite/docstring_styler/#-style-method-name-md","text":"Stylizes the given method name in markdown style Parameters class_name: string \u2013 Name of the method\u2019s parent class method_name: string \u2013 Name of the method args: string \u2013 Arguments seperated with \u2018,\u2019 Returns string \u2013 Method name stylized in markdown style Source Code 1 2 3 4 5 6 @staticmethod def _style_method_name_md ( class_name , method_name , args ): class_name = DocstringStyler . escape ( class_name ) method_name = DocstringStyler . escape ( method_name ) return f \"### * { class_name } *.** { method_name } **`#!py3 { args } ` {{ # { method_name } data-toc-label= { method_name } }}\\n\\n \"","title":"_style_method_name_md"},{"location":"stibnite/stibnite/docstring_styler/#-style-source-code-md","text":"Stylizes the source code in markdown style Parameters source_code: string \u2013 The source code that is going to be stylized Returns string \u2013 The source code stylized in markdown style Source Code 1 2 3 4 5 6 7 8 9 10 @staticmethod def _style_source_code_md ( source_code ): # Fixes indentations source = source_code . split ( \" \\n \" ) nb_indent = len ( source [ 0 ]) - len ( source [ 0 ] . lstrip ()) source_code = \"\" for i in range ( len ( source )): source_code += f \" \\t { source [ i ][ nb_indent :] } \\n \" return f '??? info \"Source Code\" \\n\\t ```py3 linenums=\"1 1 2\" \\n\\n { source_code } \\n\\t ``` \\n\\n '","title":"_style_source_code_md"},{"location":"stibnite/stibnite/docstring_styler/#get-styled-structure","text":"Stylizes the given file structure Parameters file_structure: stibnite.file_operations.FolderType \u2013 The root of the file structure that is going to be traversed to stylize Returns stibnite.file_operations.FolderType \u2013 The same root but each documentation field in stibnite.file_operations.FileType under the file structure of the root is filled with stylized documentation text Source Code 1 2 3 def get_styled_structure ( self , file_structure ): return eval ( f \"utils.traverse_file_structure(file_structure, DocstringStyler._style_file_ { self . output_style } , input_style=self.input_style)\" )","title":"get_styled_structure"},{"location":"stibnite/stibnite/documentation_manager/","text":"DocumentationManager class \u00b6 This class handles with general documentation operations like reading,styling and writing. Parameters source_path: string \u2013 The path of the folder that contains source code output_path: string \u2013 The path of the folder that is going to contain outputs os_name: string \u2013 Name of the os that the user is using output_style: string \u2013 Name of the style that the documentation will be written in input_style: string \u2013 Name of the style that the documentation is written in class functions & static methods: __init__ get_file_structure get_styled_structure write_file_structure __init__ ( self , source_path , output_path , os_name , output_style , input_style ) \u00b6 Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 def __init__ ( self , source_path , output_path , os_name , output_style , input_style ): self . package_name = os . path . abspath ( source_path ) . split ( constants . SEPARATOR_DICT [ os_name ])[ - 1 ] self . package_path = os . path . abspath ( source_path ) self . documentation_name = os . path . abspath ( output_path ) . split ( constants . SEPARATOR_DICT [ os_name ])[ - 1 ] self . documentation_path = os . path . abspath ( output_path ) self . os_name = os_name self . input_style = input_style self . output_style = output_style self . file_operator = file_operations . FileOperations ( self . package_path , self . documentation_path , self . documentation_name , self . os_name ) self . file_structure = self . get_styled_structure ( self . get_file_structure ()) get_file_structure ( self ) \u00b6 Reads the source code and returns a file structure which is like a file tree that contains all the information about the source code. Returns stibnite.file_operations.FolderType \u2013 The root of the file structure Source Code 1 2 3 def get_file_structure ( self ): return self . file_operator . read_file_structure () get_styled_structure ( self , file_structure ) \u00b6 Stylizes and creates the documentation of the source code. Parameters file_structure: stibnite.file_operations.FolderType \u2013 The root of a file structure Returns stibnite.file_operations.FolderType \u2013 The same root but each documentation field in stibnite.file_operations.FileType under the file structure of the root is filled with stylized documentation text Source Code 1 2 3 def get_styled_structure ( self , file_structure ): return docstring_styler . DocstringStyler ( self . output_style , self . input_style ) . get_styled_structure ( file_structure ) write_file_structure ( self ) \u00b6 Writes the documentation and other necessary files for mkdocs. Source Code 1 2 3 def write_file_structure ( self ): self . file_operator . write_file_structure ( self . file_structure )","title":"Documentation manager"},{"location":"stibnite/stibnite/documentation_manager/#DocumentationManager","text":"This class handles with general documentation operations like reading,styling and writing. Parameters source_path: string \u2013 The path of the folder that contains source code output_path: string \u2013 The path of the folder that is going to contain outputs os_name: string \u2013 Name of the os that the user is using output_style: string \u2013 Name of the style that the documentation will be written in input_style: string \u2013 Name of the style that the documentation is written in class functions & static methods: __init__ get_file_structure get_styled_structure write_file_structure","title":"DocumentationManager"},{"location":"stibnite/stibnite/documentation_manager/#--init--","text":"Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 def __init__ ( self , source_path , output_path , os_name , output_style , input_style ): self . package_name = os . path . abspath ( source_path ) . split ( constants . SEPARATOR_DICT [ os_name ])[ - 1 ] self . package_path = os . path . abspath ( source_path ) self . documentation_name = os . path . abspath ( output_path ) . split ( constants . SEPARATOR_DICT [ os_name ])[ - 1 ] self . documentation_path = os . path . abspath ( output_path ) self . os_name = os_name self . input_style = input_style self . output_style = output_style self . file_operator = file_operations . FileOperations ( self . package_path , self . documentation_path , self . documentation_name , self . os_name ) self . file_structure = self . get_styled_structure ( self . get_file_structure ())","title":"__init__"},{"location":"stibnite/stibnite/documentation_manager/#get-file-structure","text":"Reads the source code and returns a file structure which is like a file tree that contains all the information about the source code. Returns stibnite.file_operations.FolderType \u2013 The root of the file structure Source Code 1 2 3 def get_file_structure ( self ): return self . file_operator . read_file_structure ()","title":"get_file_structure"},{"location":"stibnite/stibnite/documentation_manager/#get-styled-structure","text":"Stylizes and creates the documentation of the source code. Parameters file_structure: stibnite.file_operations.FolderType \u2013 The root of a file structure Returns stibnite.file_operations.FolderType \u2013 The same root but each documentation field in stibnite.file_operations.FileType under the file structure of the root is filled with stylized documentation text Source Code 1 2 3 def get_styled_structure ( self , file_structure ): return docstring_styler . DocstringStyler ( self . output_style , self . input_style ) . get_styled_structure ( file_structure )","title":"get_styled_structure"},{"location":"stibnite/stibnite/documentation_manager/#write-file-structure","text":"Writes the documentation and other necessary files for mkdocs. Source Code 1 2 3 def write_file_structure ( self ): self . file_operator . write_file_structure ( self . file_structure )","title":"write_file_structure"},{"location":"stibnite/stibnite/file_operations/","text":"FileOperations class \u00b6 Main class for File Operations Parameters package_path: string \u2013 path of the source package documentation_path: string \u2013 path of the documentation will be create documentation_name: string \u2013 name of the documentation will be create os_name: string \u2013 name of the os that user is using class functions & static methods: __create_template_ignore_file __init__ read_file_structure write_file_structure __create_template_ignore_file ( self ) \u00b6 Source Code 1 2 3 def __create_template_ignore_file ( self ): with open ( f \" { self . documentation_path }{ self . separator } ignored_prefixes_and_names.json\" , \"w\" , encoding = \"utf-8\" ) as json_file : json_file . write ( json . dumps ( constants . IGNORE_JSON_TEMPLATE )) __init__ ( self , package_path , documentation_path , documentation_name , os_name ) \u00b6 Source Code 1 2 3 4 5 6 def __init__ ( self , package_path , documentation_path , documentation_name , os_name ): self . package_path = package_path self . documentation_path = documentation_path self . documentation_name = documentation_name self . os_name = os_name self . separator = constants . SEPARATOR_DICT [ self . os_name ] read_file_structure ( self ) \u00b6 Reads the whole package and its subpackages and returns a file structure. Returns stibnite.file_operations.FolderType \u2013 a file structure of the source package Source Code 1 2 3 4 5 def read_file_structure ( self ): sys . path . insert ( 0 , self . package_path ) self . __create_template_ignore_file () return build_file_tree ( self . package_path , self . documentation_path , self . separator ) write_file_structure ( self , file_structure ) \u00b6 Writes the documentation of the whole file structure and some other necessary files to run mkdocs such as index page and yaml file. Parameters file_structure: stibnite.file_operations.FolderType \u2013 the root of the file structure that is going to be written Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def write_file_structure ( self , file_structure ): self . documentation_path = os . path . join ( os . path . abspath ( self . documentation_path ), \"docs\" ) if not os . path . exists ( self . documentation_path ): os . mkdir ( self . documentation_path ) current_path = f \" { self . documentation_path }{ self . separator }{ file_structure . name } \" if not os . path . exists ( current_path ): os . mkdir ( current_path ) toc = write_file_tree ( file_structure , current_path , self . documentation_path , self . separator , \"\" , 1 ) yml_path = os . path . join ( self . separator . join ( self . documentation_path . split ( self . separator )[: - 1 ]), 'mkdocs.yml' ) if not os . path . isfile ( yml_path ): create_yaml_file ( self . documentation_name , yml_path , toc ) index_path = os . path . join ( self . documentation_path , 'index.md' ) if not os . path . isfile ( index_path ): create_index_file ( self . documentation_name , index_path , f \" { self . package_path }{ self . separator } \" ) FileType class \u00b6 This is a class that represents a python file or a leaf in a tree and contains classes and functions of the same python file. Parameters name: string \u2013 Name of the file classes: list of stibnite.core_types.ClassType \u2013 Classes in the file functions: list of stibnite.core_types.FunctionType \u2013 Functions in the file class functions & static methods: __init__ __init__ ( self , name , classes , functions ) \u00b6 Source Code 1 2 3 4 5 def __init__ ( self , name , classes , functions ): self . name = name self . classes = classes self . functions = functions self . folders = None FolderType class \u00b6 This is a class that represents a folder or a node in a tree and contains other files or folder in it. Parameters name: string \u2013 Name of the file class functions & static methods: __init__ add_file add_folder get_element __init__ ( self , name ) \u00b6 Source Code 1 2 3 4 def __init__ ( self , name ): self . name = name self . folders = {} self . files = {} add_file ( self , file ) \u00b6 Appends the given file to its file list. Parameters file: stibnite.file_operations.FileType \u2013 File that is going to be added Source Code 1 2 3 def add_file ( self , file ): self . files [ file . name ] = file add_folder ( self , folder ) \u00b6 Appends the given folder to its folder list. Parameters folder: stibnite.file_operations.FolderType \u2013 Folder that is going to be added Source Code 1 2 3 def add_folder ( self , folder ): self . folders [ folder . name ] = folder get_element ( self , name ) \u00b6 Returns the file/folder with the given name if this folder contains it. Parameters name: string \u2013 Name of the file/folder Returns stibnite.file_operations.FileType or stibnite.file_operations.FolderType or None \u2013 The file/folder with the given name Source Code 1 2 3 4 5 6 7 8 def get_element ( self , name ): if name in self . folders : return self . folders [ name ] elif name in self . files : return self . files [ name ] else : return None build_file_tree ( package_path , documentation_path , separator ) \u00b6 Recursively reads and builds the file structure. Parameters package_path: string \u2013 the source path that is going to be read documentation_path: string \u2013 the path of the folder that is going to contain outputs separator: string \u2013 seperator of the file system of the os Returns stibnite.file_operations.FolderType \u2013 the root of a file tree Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def build_file_tree ( package_path , documentation_path , separator ): for path , dirs , files in os . walk ( package_path ): if len ( dirs ) == 0 and len ( files ) == 0 : return None current_node = FolderType ( path . split ( separator )[ - 1 ]) for directory in dirs : if not is_ignored ( directory , f \" { documentation_path }{ separator } \" ): node_candidate = build_file_tree ( os . path . join ( path , directory ), documentation_path , separator ) if node_candidate is not None : current_node . add_folder ( node_candidate ) for file in files : if not is_ignored ( file , f \" { documentation_path }{ separator } \" ) and file . split ( '.' )[ - 1 ] == \"py\" : module = import_module ( file . split ( '.' )[ 0 ], os . path . join ( path , file )) classes = [ core_types . ClassType ( obj ) for name , obj in inspect . getmembers ( module , inspect . isclass ) if obj . __module__ == module . __name__ ] functions = [ core_types . FunctionType ( obj ) for name , obj in inspect . getmembers ( module , inspect . isfunction ) if obj . __module__ == module . __name__ ] current_node . add_file ( FileType ( file , functions = functions , classes = classes )) return current_node create_index_file ( project_name , index_file_path , package_path ) \u00b6 Creates and writes the index file. Parameters project_name: string \u2013 Name of the project index_file_path: string \u2013 The path of the index file that is going to be written at package_path: string \u2013 path of the source package Source Code 1 2 3 4 5 6 7 8 9 10 11 12 def create_index_file ( project_name , index_file_path , package_path ): index_file = open ( index_file_path , \"w\" , encoding = \"utf-8\" ) try : with open ( f \" { package_path } README.md\" , \"r\" , encoding = \"utf-8\" ) as fh : long_description = fh . read () except : long_description = \"\" content = f # Welcome to {project_name} { long_description } index_file . writelines ( content ) index_file . close () create_yaml_file ( project_name , yaml_file_path , toc ) \u00b6 Creates and writes the yaml file. Parameters project_name: string \u2013 name of the project yaml_file_path: string \u2013 the path of the yaml file that is going to be written at toc: string \u2013 contents of the yaml file Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def create_yaml_file ( project_name , yaml_file_path , toc ): yaml_file = open ( yaml_file_path , \"w\" , encoding = \"utf-8\" ) content = fsite_name : { project_name } theme : name : 'material' palette : primary : indigo features : - navigation . tabs icon : repo : fontawesome / brands / git - alt repo_name : csci - arch / stibnite repo_url : https : // github . com / csci - arch / stibnite nav : - Home : index . md { toc } markdown_extensions : - toc : toc_depth : 3 permalink : True - extra - smarty - codehilite - admonition - pymdownx . details - pymdownx . superfences - pymdownx . emoji - pymdownx . inlinehilite - pymdownx . magiclink yaml_file . writelines ( content ) yaml_file . close () import_module ( module_name , module_path ) \u00b6 Import the given module and returns an object of it. Parameters module_name: string \u2013 Name of the module that is going to be imported module_path: string \u2013 Path of the module that is going to be imported Returns object \u2013 A live object of the imported module Source Code 1 2 3 4 5 6 7 def import_module ( module_name , module_path ): spec = module_loader . spec_from_file_location ( module_name , module_path ) module = module_loader . module_from_spec ( spec ) sys . modules [ module_name ] = module spec . loader . exec_module ( module ) return module is_ignored ( name , documentation_path ) \u00b6 Checks if the given name has a ignored prefix or name. Parameters name: string \u2013 file or folder name documentation_path: string \u2013 path of the documentation Returns bool \u2013 has a ignored prefix, name or not Source Code 1 2 3 4 5 6 7 8 9 def is_ignored ( name , documentation_path ): ignored_dict = json . loads ( get_json_file ( documentation_path )) for prefix in ignored_dict [ \"prefixes\" ]: if name [: len ( prefix )] == prefix : return True if name in ignored_dict [ 'names' ]: return True return False write_file_tree ( element , current_path , output_path , separator , toc , depth ) \u00b6 Recursively writes the documentation and creates the yaml file. Parameters element: stibnite.file_operations.FolderType \u2013 the current folder in the file tree current_path: string \u2013 path of the current folder in the file tree output_path: string \u2013 the path of the folder that is going to contain outputs separator: string \u2013 seperator of the file system of the os toc: string \u2013 contents of the yaml file depth: int \u2013 the depth of the recursive function currently in Returns string \u2013 contents of the yaml file Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def write_file_tree ( element , current_path , output_path , separator , toc , depth ): toc += \" \" * depth + \"- \" + element . name + \": \\n \" if len ( element . folders ) > 0 : for name , folder in element . folders . items (): new_path = f ' { current_path }{ separator }{ name } ' if not os . path . exists ( new_path ): os . mkdir ( new_path ) toc = write_file_tree ( folder , new_path , output_path , separator , toc , depth + 1 ) if len ( element . files ) > 0 : for name , file in element . files . items (): if file . documentation [ constants . CONTENT ] != \"\" : file_p = open ( f \" { current_path }{ separator }{ name . split ( '.' )[ 0 ] } . { file . documentation [ constants . FORMAT ] } \" , \"w\" , encoding = \"utf-8\" ) file_p . write ( file . documentation [ constants . CONTENT ]) file_p . close () toc += \" \" * ( depth + 1 ) + \"- \" + f \" { '/' . join ( current_path [ len ( output_path ) + 1 :] . split ( separator )) } \" \\ f \"/ { name . split ( '.' )[ 0 ] } . { file . documentation [ constants . FORMAT ] } \\n \" return toc","title":"File operations"},{"location":"stibnite/stibnite/file_operations/#FileOperations","text":"Main class for File Operations Parameters package_path: string \u2013 path of the source package documentation_path: string \u2013 path of the documentation will be create documentation_name: string \u2013 name of the documentation will be create os_name: string \u2013 name of the os that user is using class functions & static methods: __create_template_ignore_file __init__ read_file_structure write_file_structure","title":"FileOperations"},{"location":"stibnite/stibnite/file_operations/#--create-template-ignore-file","text":"Source Code 1 2 3 def __create_template_ignore_file ( self ): with open ( f \" { self . documentation_path }{ self . separator } ignored_prefixes_and_names.json\" , \"w\" , encoding = \"utf-8\" ) as json_file : json_file . write ( json . dumps ( constants . IGNORE_JSON_TEMPLATE ))","title":"__create_template_ignore_file"},{"location":"stibnite/stibnite/file_operations/#--init--","text":"Source Code 1 2 3 4 5 6 def __init__ ( self , package_path , documentation_path , documentation_name , os_name ): self . package_path = package_path self . documentation_path = documentation_path self . documentation_name = documentation_name self . os_name = os_name self . separator = constants . SEPARATOR_DICT [ self . os_name ]","title":"__init__"},{"location":"stibnite/stibnite/file_operations/#read-file-structure","text":"Reads the whole package and its subpackages and returns a file structure. Returns stibnite.file_operations.FolderType \u2013 a file structure of the source package Source Code 1 2 3 4 5 def read_file_structure ( self ): sys . path . insert ( 0 , self . package_path ) self . __create_template_ignore_file () return build_file_tree ( self . package_path , self . documentation_path , self . separator )","title":"read_file_structure"},{"location":"stibnite/stibnite/file_operations/#write-file-structure","text":"Writes the documentation of the whole file structure and some other necessary files to run mkdocs such as index page and yaml file. Parameters file_structure: stibnite.file_operations.FolderType \u2013 the root of the file structure that is going to be written Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def write_file_structure ( self , file_structure ): self . documentation_path = os . path . join ( os . path . abspath ( self . documentation_path ), \"docs\" ) if not os . path . exists ( self . documentation_path ): os . mkdir ( self . documentation_path ) current_path = f \" { self . documentation_path }{ self . separator }{ file_structure . name } \" if not os . path . exists ( current_path ): os . mkdir ( current_path ) toc = write_file_tree ( file_structure , current_path , self . documentation_path , self . separator , \"\" , 1 ) yml_path = os . path . join ( self . separator . join ( self . documentation_path . split ( self . separator )[: - 1 ]), 'mkdocs.yml' ) if not os . path . isfile ( yml_path ): create_yaml_file ( self . documentation_name , yml_path , toc ) index_path = os . path . join ( self . documentation_path , 'index.md' ) if not os . path . isfile ( index_path ): create_index_file ( self . documentation_name , index_path , f \" { self . package_path }{ self . separator } \" )","title":"write_file_structure"},{"location":"stibnite/stibnite/file_operations/#FileType","text":"This is a class that represents a python file or a leaf in a tree and contains classes and functions of the same python file. Parameters name: string \u2013 Name of the file classes: list of stibnite.core_types.ClassType \u2013 Classes in the file functions: list of stibnite.core_types.FunctionType \u2013 Functions in the file class functions & static methods: __init__","title":"FileType"},{"location":"stibnite/stibnite/file_operations/#--init--","text":"Source Code 1 2 3 4 5 def __init__ ( self , name , classes , functions ): self . name = name self . classes = classes self . functions = functions self . folders = None","title":"__init__"},{"location":"stibnite/stibnite/file_operations/#FolderType","text":"This is a class that represents a folder or a node in a tree and contains other files or folder in it. Parameters name: string \u2013 Name of the file class functions & static methods: __init__ add_file add_folder get_element","title":"FolderType"},{"location":"stibnite/stibnite/file_operations/#--init--","text":"Source Code 1 2 3 4 def __init__ ( self , name ): self . name = name self . folders = {} self . files = {}","title":"__init__"},{"location":"stibnite/stibnite/file_operations/#add-file","text":"Appends the given file to its file list. Parameters file: stibnite.file_operations.FileType \u2013 File that is going to be added Source Code 1 2 3 def add_file ( self , file ): self . files [ file . name ] = file","title":"add_file"},{"location":"stibnite/stibnite/file_operations/#add-folder","text":"Appends the given folder to its folder list. Parameters folder: stibnite.file_operations.FolderType \u2013 Folder that is going to be added Source Code 1 2 3 def add_folder ( self , folder ): self . folders [ folder . name ] = folder","title":"add_folder"},{"location":"stibnite/stibnite/file_operations/#get-element","text":"Returns the file/folder with the given name if this folder contains it. Parameters name: string \u2013 Name of the file/folder Returns stibnite.file_operations.FileType or stibnite.file_operations.FolderType or None \u2013 The file/folder with the given name Source Code 1 2 3 4 5 6 7 8 def get_element ( self , name ): if name in self . folders : return self . folders [ name ] elif name in self . files : return self . files [ name ] else : return None","title":"get_element"},{"location":"stibnite/stibnite/file_operations/#build-file-tree","text":"Recursively reads and builds the file structure. Parameters package_path: string \u2013 the source path that is going to be read documentation_path: string \u2013 the path of the folder that is going to contain outputs separator: string \u2013 seperator of the file system of the os Returns stibnite.file_operations.FolderType \u2013 the root of a file tree Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def build_file_tree ( package_path , documentation_path , separator ): for path , dirs , files in os . walk ( package_path ): if len ( dirs ) == 0 and len ( files ) == 0 : return None current_node = FolderType ( path . split ( separator )[ - 1 ]) for directory in dirs : if not is_ignored ( directory , f \" { documentation_path }{ separator } \" ): node_candidate = build_file_tree ( os . path . join ( path , directory ), documentation_path , separator ) if node_candidate is not None : current_node . add_folder ( node_candidate ) for file in files : if not is_ignored ( file , f \" { documentation_path }{ separator } \" ) and file . split ( '.' )[ - 1 ] == \"py\" : module = import_module ( file . split ( '.' )[ 0 ], os . path . join ( path , file )) classes = [ core_types . ClassType ( obj ) for name , obj in inspect . getmembers ( module , inspect . isclass ) if obj . __module__ == module . __name__ ] functions = [ core_types . FunctionType ( obj ) for name , obj in inspect . getmembers ( module , inspect . isfunction ) if obj . __module__ == module . __name__ ] current_node . add_file ( FileType ( file , functions = functions , classes = classes )) return current_node","title":"build_file_tree"},{"location":"stibnite/stibnite/file_operations/#create-index-file","text":"Creates and writes the index file. Parameters project_name: string \u2013 Name of the project index_file_path: string \u2013 The path of the index file that is going to be written at package_path: string \u2013 path of the source package Source Code 1 2 3 4 5 6 7 8 9 10 11 12 def create_index_file ( project_name , index_file_path , package_path ): index_file = open ( index_file_path , \"w\" , encoding = \"utf-8\" ) try : with open ( f \" { package_path } README.md\" , \"r\" , encoding = \"utf-8\" ) as fh : long_description = fh . read () except : long_description = \"\" content = f # Welcome to {project_name} { long_description } index_file . writelines ( content ) index_file . close ()","title":"create_index_file"},{"location":"stibnite/stibnite/file_operations/#create-yaml-file","text":"Creates and writes the yaml file. Parameters project_name: string \u2013 name of the project yaml_file_path: string \u2013 the path of the yaml file that is going to be written at toc: string \u2013 contents of the yaml file Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def create_yaml_file ( project_name , yaml_file_path , toc ): yaml_file = open ( yaml_file_path , \"w\" , encoding = \"utf-8\" ) content = fsite_name : { project_name } theme : name : 'material' palette : primary : indigo features : - navigation . tabs icon : repo : fontawesome / brands / git - alt repo_name : csci - arch / stibnite repo_url : https : // github . com / csci - arch / stibnite nav : - Home : index . md { toc } markdown_extensions : - toc : toc_depth : 3 permalink : True - extra - smarty - codehilite - admonition - pymdownx . details - pymdownx . superfences - pymdownx . emoji - pymdownx . inlinehilite - pymdownx . magiclink yaml_file . writelines ( content ) yaml_file . close ()","title":"create_yaml_file"},{"location":"stibnite/stibnite/file_operations/#import-module","text":"Import the given module and returns an object of it. Parameters module_name: string \u2013 Name of the module that is going to be imported module_path: string \u2013 Path of the module that is going to be imported Returns object \u2013 A live object of the imported module Source Code 1 2 3 4 5 6 7 def import_module ( module_name , module_path ): spec = module_loader . spec_from_file_location ( module_name , module_path ) module = module_loader . module_from_spec ( spec ) sys . modules [ module_name ] = module spec . loader . exec_module ( module ) return module","title":"import_module"},{"location":"stibnite/stibnite/file_operations/#is-ignored","text":"Checks if the given name has a ignored prefix or name. Parameters name: string \u2013 file or folder name documentation_path: string \u2013 path of the documentation Returns bool \u2013 has a ignored prefix, name or not Source Code 1 2 3 4 5 6 7 8 9 def is_ignored ( name , documentation_path ): ignored_dict = json . loads ( get_json_file ( documentation_path )) for prefix in ignored_dict [ \"prefixes\" ]: if name [: len ( prefix )] == prefix : return True if name in ignored_dict [ 'names' ]: return True return False","title":"is_ignored"},{"location":"stibnite/stibnite/file_operations/#write-file-tree","text":"Recursively writes the documentation and creates the yaml file. Parameters element: stibnite.file_operations.FolderType \u2013 the current folder in the file tree current_path: string \u2013 path of the current folder in the file tree output_path: string \u2013 the path of the folder that is going to contain outputs separator: string \u2013 seperator of the file system of the os toc: string \u2013 contents of the yaml file depth: int \u2013 the depth of the recursive function currently in Returns string \u2013 contents of the yaml file Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def write_file_tree ( element , current_path , output_path , separator , toc , depth ): toc += \" \" * depth + \"- \" + element . name + \": \\n \" if len ( element . folders ) > 0 : for name , folder in element . folders . items (): new_path = f ' { current_path }{ separator }{ name } ' if not os . path . exists ( new_path ): os . mkdir ( new_path ) toc = write_file_tree ( folder , new_path , output_path , separator , toc , depth + 1 ) if len ( element . files ) > 0 : for name , file in element . files . items (): if file . documentation [ constants . CONTENT ] != \"\" : file_p = open ( f \" { current_path }{ separator }{ name . split ( '.' )[ 0 ] } . { file . documentation [ constants . FORMAT ] } \" , \"w\" , encoding = \"utf-8\" ) file_p . write ( file . documentation [ constants . CONTENT ]) file_p . close () toc += \" \" * ( depth + 1 ) + \"- \" + f \" { '/' . join ( current_path [ len ( output_path ) + 1 :] . split ( separator )) } \" \\ f \"/ { name . split ( '.' )[ 0 ] } . { file . documentation [ constants . FORMAT ] } \\n \" return toc","title":"write_file_tree"},{"location":"stibnite/stibnite/main/","text":"main ( argv = None ) \u00b6 Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def main ( argv = None ): argv = sys . argv if argv is None else argv print ( argv ) DocumentationManager ( argv [ 1 ], argv [ 2 ], platform . system (), input_style = constants . RESTRUCTERED , output_style = constants . MARKDOWN ) . write_file_structure () os . chdir ( argv [ 2 ]) call ([ \"mkdocs\" , \"build\" , \"--clean\" ]) call ([ \"mkdocs\" , \"serve\" ]) webbrowser . open ( \"http://127.0.0.1:8000/\" )","title":"Main"},{"location":"stibnite/stibnite/main/#main","text":"Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def main ( argv = None ): argv = sys . argv if argv is None else argv print ( argv ) DocumentationManager ( argv [ 1 ], argv [ 2 ], platform . system (), input_style = constants . RESTRUCTERED , output_style = constants . MARKDOWN ) . write_file_structure () os . chdir ( argv [ 2 ]) call ([ \"mkdocs\" , \"build\" , \"--clean\" ]) call ([ \"mkdocs\" , \"serve\" ]) webbrowser . open ( \"http://127.0.0.1:8000/\" )","title":"main"},{"location":"stibnite/stibnite/utils/","text":"traverse_file_structure ( current , function , ** inner_function_args ) \u00b6 Recursively traverses the given folder and applies the function to every file that it finds. Parameters current: stibnite.file_operations.FolderType \u2013 Source folder function: function \u2013 The function that will be applied to files of the current folder inner_function_args: dictionary of sting to object \u2013 Arguments of the inner function Returns stibnite.file_operations.FolderType \u2013 The same source folder Source Code 1 2 3 4 5 6 7 8 9 10 def traverse_file_structure ( current , function , ** inner_function_args ): if len ( current . folders ) > 0 : for folder in current . folders . keys (): traverse_file_structure ( current . get_element ( folder ), function , ** inner_function_args ) if len ( current . files ) > 0 : for file in current . files . keys (): current . files [ file ] = function ( current . files [ file ], ** inner_function_args ) return current","title":"Utils"},{"location":"stibnite/stibnite/utils/#traverse-file-structure","text":"Recursively traverses the given folder and applies the function to every file that it finds. Parameters current: stibnite.file_operations.FolderType \u2013 Source folder function: function \u2013 The function that will be applied to files of the current folder inner_function_args: dictionary of sting to object \u2013 Arguments of the inner function Returns stibnite.file_operations.FolderType \u2013 The same source folder Source Code 1 2 3 4 5 6 7 8 9 10 def traverse_file_structure ( current , function , ** inner_function_args ): if len ( current . folders ) > 0 : for folder in current . folders . keys (): traverse_file_structure ( current . get_element ( folder ), function , ** inner_function_args ) if len ( current . files ) > 0 : for file in current . files . keys (): current . files [ file ] = function ( current . files [ file ], ** inner_function_args ) return current","title":"traverse_file_structure"}]}